import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.ClipboardOwner;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.Transferable;
import java.io.File;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

/**
  Parse occultation data, and format it as javascript.
  
  The source data is output by occult.exe, from the IOTA.
  http://www.lunar-occultations.com/iota/occult4.htm
  
  The source data (.txt files) is here:
  C:\Program Files (x86)\occult\AutoGenerated Lunar\
  one directory for each location.
 
  Example file name: 
  'C:\Program Files (x86)\occult\AutoGenerated Lunar\Oshawa ON\20161016 to 20161016 Oshawa ON.txt'
  
  Format:
'  
Occultation prediction for Ottawa ON
W 75.7,  N 45.4

   Date     Star  Mag Ph  El    U.T.    a    b    P
 y   m  d    No            o   h   m    m    m    o
16 Oct 19    661  4.5 RD 138   2  8.9 +0.0 +1.8 239
'

 TO GENERATE USING occult.exe:
  * Occult > Lunar predictions > Predictions of multiple objects for multiple sites
  * use the ZC catalog only! (otherwise wacky interference between dates and star names)
  * limiting mag no more than 6.0 (RASC has 5.9)
  * use the 'John' site file, to use my list of 'standard' sites (listed below)
  * do at least 13 months at a time (till end of year + 1 month)
  * 'Compute Occultations' will generate the files

  Here are my 15+16+6=37 chosen sites:
  (95+% of the population of North America will be within 500km of one of these stations)
  St. John's
  Halifax
  Québec
  Montreal
  Ottawa
  Toronto
  Sault Ste. Marie
  Thunder Bay
  Winnipeg
  Saskatoon
  Edmonton
  Vancouver
  Whitehorse
  Yellowknife
  Iqaluit
  
  Boston
  Washington, DC
  Atlanta
  Miami
  Chicago
  Kansas City, Kansas
  Austin
  Denver
  Los Angeles
  San Francisco
  Boise 
  Portland, Oregon
  Salt Lake City
  Sioux Falls
  Great Falls
  Anchorage
  
  London
  Edinburgh
  Manchester
  Exeter
  Athlone (center of Ireland, for Eire and Northern Ireland)
  Thurso (top of Scotland)
  
<P>Compile and run the old fashioned way:
  <pre>
%astro%\dev\occultation>C:\jdk1.6.0\bin\javac -encoding "UTF-8" -cp . OccultationParser.java
%astro%\dev\occultation>C:\jdk1.6.0\bin\java OccultationParser
  </pre>
  
 */
public class OccultationParser {
  
  /** Run the script, output to a file. */
  public static void main(String... args)  throws IOException {
    log("Starting the script.");
    log("Root directory: " + BASE_DIR);
    OccultationParser script = new OccultationParser();
    script.parseAndGenerate();
    log("Done. Output is in: " + OUTPUT_FILE);
  }
  
  public static final String BASE_DIR = "C:\\Program Files (x86)\\occult\\AutoGenerated Lunar";
  public static final String OUTPUT_FILE = "output.js";

  // PRIVATE
  
  private static final String NL = System.getProperty("line.separator");
  private static final String WS = "\\s+";

  private static final class Event {
    String UT = "";
    String star = "";
    String mag = "";
    String ph = "";
    String el = "";
    String pa = "";
    String a = "";
    String b = "";
    public String toString(){
      StringBuilder result = new StringBuilder();
      result.append("{UT:'" + UT + "', star:'"+star+"', mag:"+mag+", ph:'"+ph+"', el:"+el+", pa:"+pa+", a:"+a+ ", b:"+b+"}");
      return result.toString();
    }
  }
  

  /** Each file corresponds to a single Station. */
  private static final class Station {
    String NAME = "";
    String LAT = "";
    String LONG = "";
    List<Event> EVENTS = new ArrayList<Event>();
    /*
      {
        name : 'Montréal', 
        λ:-73.6, 
        φ:45.5, 
        events: [
          {UT:'2016-10-20 21:08:18', star:'ZC 123', mag:5.5, ph:'DD', el:92, pa:145, a:+1.2, b:-1.5}
        ]
      }
    */
    public String toString(){
      StringBuilder result = new StringBuilder();
      result.append("  {" + NL);
      result.append("    name: '" + NAME + "'," + NL);
      result.append("    λ:" + LONG + "," + NL); 
      result.append("    φ:" + LAT + "," +  NL);
      result.append("    events: [" + NL);
      for (int i = 0; i < EVENTS.size(); ++i){
        String comma = (i == EVENTS.size() - 1 ) ? "" : ","; 
        result.append("      " + EVENTS.get(i).toString() + comma + NL);
      }
      result.append("    ]" + NL);
      result.append("  }");
      return result.toString();
    }
  }

  private void parseAndGenerate() throws IOException{
    List<File> files = getFileListing(new File(BASE_DIR));
    String result = "";
    for (File file : files){
      log("File: " + file.getName());
      Station station = new Station();
      station.NAME = stationName(file);
      log("  Station: " + station.NAME);
      List<String> lines = read(file);
      addStationPosition(station, lines.get(2));
      for(String line : lines){
        if (line.matches("^\\d.*")){ //starts with a number
          station.EVENTS.add(parseEvent(line));
        }
      }
      log("  Num events: " + station.EVENTS.size());
      //log(station.toString());
      result = result + station.toString() + "," + NL; 
    }
    output(result);
  }
  
  /** All .txt files beneath a root directory (recursive!). */
  private List<File> getFileListing(File aStartingDir) throws FileNotFoundException {
    List<File> result = new ArrayList<File>();
    File[] filesAndDirs = aStartingDir.listFiles();
    List<File> filesDirs = Arrays.asList(filesAndDirs);
    for(File file : filesDirs) {
      if (file.isFile() && file.getName().endsWith(".txt")){
        result.add(file); 
      }
      if (! file.isFile()) {
        //must be a directory
        //recursive call!
        List<File> deeperList = getFileListing(file);
        result.addAll(deeperList);
      }
    }
    return result;
  }
  
  private String stationName(File file){
    //20161016 to 20161016 Oshawa ON.txt
    String[] parts = file.getName().split(WS);
    return parts[3]; 
  }
  
  private List<String> read(File file) throws IOException {
    List<String> result = new ArrayList<String>();
    Scanner scanner = new Scanner(new FileInputStream(file), "UTF-8");
    try {
      while (scanner.hasNextLine()){
        result.add(scanner.nextLine());
      }
    }
    finally{
      scanner.close();
    }
    return result;
  }
  
  private void addStationPosition(Station station, String line){
    //W 78.9,  N 43.9                                        --- starts with 'W', for North America
    String[] parts = line.split(WS);
    station.LAT = parts[3];
    station.LONG = parts[1].substring(0, parts[1].length()-1); //chop off the trailing comma
    if (parts[0].equals("W")){
      station.LONG = "-" + station.LONG; 
    }
    if (parts[2].equals("S")){
      station.LAT = "-" + station.LAT; 
    }
  }

  private static final Map<String, String> MONTH = new LinkedHashMap<String, String>();
  static {
    MONTH.put("Jan", "01");
    MONTH.put("Feb", "02");
    MONTH.put("Mar", "03");
    MONTH.put("Apr", "04");
    MONTH.put("May", "05");
    MONTH.put("Jun", "06");
    MONTH.put("Jul", "07");
    MONTH.put("Aug", "08");
    MONTH.put("Sep", "09");
    MONTH.put("Oct", "10");
    MONTH.put("Nov", "11");
    MONTH.put("Dec", "12");
  }

  /* 1-based, inclusive on both ends. */
  private String parts(int start, int end, String line){
    return line.substring(start-1, end).trim();
  }
  
  private Event parseEvent(String line){
    Event result = new Event();
    //Date     Star  Mag Ph  El    U.T.    a    b    P
    //y   m  d    No            o   h   m    m    m    o
    //16 Oct 19    661  4.5 RD 138   2  8.9 +0.0 +1.8 239
    // 0  1   2     3    4   5   6   7   8    9    10  11
    log("      Event line: " + line);
    result.UT = "20" + parts(1,2,line) + "-" + MONTH.get(parts(3,6,line)) + "-" + pad0(parts(7,9,line)) + " " + pad0(parts(29,32,line)) + ":" + minuteAndSeconds(parts(33,37,line)); 
    result.star = parts(10,16,line);
    result.mag = parts(17,21,line);
    result.ph = parts(22,24,line);
    result.el = parts(25,28,line);
    result.pa = parts(48,51,line);
    result.a = parts(38,42,line);
    result.b = parts(43,47,line);
    /*
    String[] parts = line.split(WS);
    result.UT = "20" + parts[0] + "-" + MONTH.get(parts[1]) + "-" + pad0(parts[2]) + " " + pad0(parts[7]) + ":" + minuteAndSeconds(parts[8]) ; 
    result.star = parts[3];
    result.mag = parts[4];
    result.ph = parts[5];
    result.el = parts[6];
    result.pa = parts[11];
    result.a = parts[9];
    result.b = parts[10];
    */
    return result;
  }
  
  private String pad0(String thing){
    String result = thing;
    if (thing.length() == 1){
      result = "0" + result;
    }
    return result;
  }
  
  private String minuteAndSeconds(String thing /*59.8*/){
    log("   minutes:" + thing);
    String[] parts = thing.trim().split("\\.");
    String result = pad0(parts[0]) + ":";
    Integer decimal = Integer.valueOf(parts[1]);
    Integer seconds = 6 * decimal;
    result = result + pad0(seconds.toString());
    return result;
  }

  private void output(String result) throws IOException  {
    Writer out = new OutputStreamWriter(new FileOutputStream(OUTPUT_FILE), "UTF-8");
    try {
      out.write(result);
    }
    finally {
      out.close();
    }
  }
  
  private static void log(Object msg){
    System.out.println(msg.toString());
  }
}